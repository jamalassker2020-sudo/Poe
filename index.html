<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum HFT Lite</title>
  <style>
    :root { --g: #0a0; --r: #c00; --b: #07a; --y: #da0; --bg: #111; --fg: #eee; --muted: #888; --border: #333; }
    html.light { --bg: #f5f5f5; --fg: #222; --muted: #666; --border: #ccc; }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font: 11px/1.4 monospace; background: var(--bg); color: var(--fg); padding: 8px; }
    .g { color: var(--g); } .r { color: var(--r); } .b { color: var(--b); } .y { color: var(--y); } .m { color: var(--muted); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px; }
    .box { background: #1a1a1a; border: 1px solid var(--border); padding: 8px; border-radius: 4px; }
    html.light .box { background: #fff; }
    .flex { display: flex; justify-content: space-between; align-items: center; }
    .grid { display: grid; gap: 4px; }
    .stat { text-align: center; padding: 4px; }
    .stat span { display: block; font-size: 9px; color: var(--muted); }
    .big { font-size: 18px; font-weight: bold; }
    table { width: 100%; border-collapse: collapse; font-size: 10px; }
    th, td { padding: 4px; text-align: right; border-bottom: 1px solid var(--border); }
    th { color: var(--muted); font-weight: normal; }
    td:first-child, th:first-child { text-align: left; }
    .scroll { max-height: 200px; overflow-y: auto; }
    .log { font-size: 9px; padding: 2px 0; border-bottom: 1px solid var(--border); }
    .pos { padding: 4px; margin-bottom: 4px; border-left: 2px solid var(--g); background: rgba(0,170,0,0.1); }
    .pos.sell { border-color: var(--r); background: rgba(200,0,0,0.1); }
    button { background: var(--border); border: none; color: var(--fg); padding: 4px 8px; cursor: pointer; border-radius: 3px; }
    button:hover { background: #444; }
    .bar { height: 4px; background: #333; border-radius: 2px; overflow: hidden; }
    .bar-fill { height: 100%; transition: width 0.3s; }
    .chart { display: flex; align-items: flex-end; height: 50px; gap: 1px; }
    .chart div { flex: 1; background: var(--g); opacity: 0.6; min-height: 2px; }
    @media (min-width: 768px) { .col-2 { grid-template-columns: 2fr 1fr; } }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="row flex">
    <div><strong>QUANTUM HFT LITE</strong> <span class="m">| AI Trading</span></div>
    <div class="flex" style="gap:8px">
      <span id="status" class="y">INIT</span>
      <span class="m" id="apiStatus">API: --</span>
      <span class="m" id="latency">--ms</span>
      <button onclick="resetBot()">Reset</button>
    </div>
  </div>

  <!-- Stats Grid -->
  <div class="row grid" style="grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));">
    <div class="box stat"><span>EQUITY</span><div class="big" id="equity">$100</div></div>
    <div class="box stat"><span>P&L</span><div id="pnl">$0</div></div>
    <div class="box stat"><span>TRADES</span><div id="trades">0</div></div>
    <div class="box stat"><span>WIN%</span><div id="winrate">0%</div></div>
    <div class="box stat"><span>PF</span><div id="pf">0.00</div></div>
    <div class="box stat"><span>OPEN</span><div id="openPos">0/5</div></div>
    <div class="box stat"><span>STREAK</span><div id="streak">0</div></div>
    <div class="box stat"><span>PEAK</span><div id="peak">$100</div></div>
    <div class="box stat"><span>DD</span><div id="dd">0%</div></div>
    <div class="box stat"><span>SHARPE</span><div id="sharpe">0</div></div>
  </div>

  <!-- Risk Bars -->
  <div class="box row" style="flex:1">
    <div style="flex:1"><span class="m">Daily: </span><span id="dailyUsed">0%</span><div class="bar"><div class="bar-fill" id="dailyBar" style="width:0;background:var(--g)"></div></div></div>
    <div style="flex:1"><span class="m">DD: </span><span id="ddUsed">0%</span><div class="bar"><div class="bar-fill" id="ddBar" style="width:0;background:var(--b)"></div></div></div>
    <div style="flex:1"><span class="m">Exp: </span><span id="exposure">0%</span><div class="bar"><div class="bar-fill" id="expBar" style="width:0;background:var(--y)"></div></div></div>
    <div><span class="m">Kelly: </span><span id="kellySize">0.5%</span></div>
    <div id="riskLevel" class="g">LOW</div>
  </div>

  <!-- Main Grid -->
  <div class="grid col-2">
    <!-- Market Table -->
    <div class="box">
      <div class="flex" style="margin-bottom:4px">
        <strong class="b">MARKETS</strong>
        <span class="m">Tick: <span id="tickCount">0</span> | <span id="marketTime">--</span></span>
      </div>
      <div class="scroll">
        <table><thead><tr><th>SYM</th><th>BID</th><th>ASK</th><th>Î”</th><th>VOL</th><th>AI</th><th>SIG</th><th>P&L</th></tr></thead><tbody id="marketTable"></tbody></table>
      </div>
    </div>

    <!-- Right Panel -->
    <div class="grid" style="gap:8px">
      <!-- Positions -->
      <div class="box">
        <strong>POSITIONS</strong>
        <div id="positions" class="scroll" style="margin-top:4px"><span class="m">Scanning...</span></div>
      </div>
      <!-- Equity Chart -->
      <div class="box">
        <div class="flex"><strong>EQUITY</strong><span class="m" id="chartPeak">Peak: $100</span></div>
        <div class="chart" id="equityChart"></div>
      </div>
      <!-- Log -->
      <div class="box">
        <strong>LOG</strong>
        <div id="tradeLog" class="scroll" style="margin-top:4px"><span class="m">Initializing...</span></div>
      </div>
    </div>
  </div>

<script>
// ========== DARK/LIGHT MODE ==========
if (window.matchMedia && !window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.documentElement.classList.add('light');
}
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
  document.documentElement.classList.toggle('light', !e.matches);
});

// ========== INSTRUMENTS ==========
const INSTRUMENTS = [
  // Forex Majors
  { sym: 'EUR/USD', base: 'EUR', quote: 'USD', pip: 0.0001, type: 'forex', category: 'major' },
  { sym: 'GBP/USD', base: 'GBP', quote: 'USD', pip: 0.0001, type: 'forex', category: 'major' },
  { sym: 'USD/JPY', base: 'USD', quote: 'JPY', pip: 0.01, type: 'forex', category: 'major' },
  { sym: 'USD/CHF', base: 'USD', quote: 'CHF', pip: 0.0001, type: 'forex', category: 'major' },
  { sym: 'AUD/USD', base: 'AUD', quote: 'USD', pip: 0.0001, type: 'forex', category: 'major' },
  { sym: 'USD/CAD', base: 'USD', quote: 'CAD', pip: 0.0001, type: 'forex', category: 'major' },
  { sym: 'NZD/USD', base: 'NZD', quote: 'USD', pip: 0.0001, type: 'forex', category: 'major' },
  // Crosses
  { sym: 'EUR/GBP', base: 'EUR', quote: 'GBP', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'EUR/JPY', base: 'EUR', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'GBP/JPY', base: 'GBP', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'AUD/JPY', base: 'AUD', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'EUR/AUD', base: 'EUR', quote: 'AUD', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'GBP/AUD', base: 'GBP', quote: 'AUD', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'EUR/CAD', base: 'EUR', quote: 'CAD', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'GBP/CAD', base: 'GBP', quote: 'CAD', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'AUD/CAD', base: 'AUD', quote: 'CAD', pip: 0.0001, type: 'forex', category: 'cross' },
  { sym: 'NZD/JPY', base: 'NZD', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'CHF/JPY', base: 'CHF', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'CAD/JPY', base: 'CAD', quote: 'JPY', pip: 0.01, type: 'forex', category: 'cross' },
  { sym: 'AUD/NZD', base: 'AUD', quote: 'NZD', pip: 0.0001, type: 'forex', category: 'cross' },
  // Metals
  { sym: 'XAU/USD', base: 'XAU', quote: 'USD', pip: 0.01, type: 'metal', category: 'commodity' },
  { sym: 'XAG/USD', base: 'XAG', quote: 'USD', pip: 0.001, type: 'metal', category: 'commodity' },
  // Crypto
  { sym: 'BTC/USD', base: 'BTC', quote: 'USD', pip: 0.01, type: 'crypto', category: 'crypto' },
  { sym: 'ETH/USD', base: 'ETH', quote: 'USD', pip: 0.01, type: 'crypto', category: 'crypto' },
];

// ========== CONFIGURATION ==========
const CONFIG = {
  startBalance: 100,
  maxDrawdownPct: 10,
  dailyLossLimitPct: 5,
  maxPositions: 5,
  maxCorrelatedPos: 3,
  baseRiskPct: 0.5,
  kellyFraction: 0.25,
  minLot: 0.01,
  maxLot: 0.05,
  baseTpPips: 15,
  baseSlPips: 8,
  trailActivatePips: 8,
  trailDistancePips: 4,
  breakEvenPips: 5,
  tickInterval: 300,
  cooldownMs: 3000,
  signalThreshold: 70,
  aiConfidenceMin: 60,
  forexSpread: 0.8,
  metalSpread: 25,
  cryptoSpread: 0.05,
};

// ========== STATE ==========
let state = loadState() || createFreshState();
let prices = {}, priceHistory = {}, lastPrices = {}, rates = {}, cryptoPrices = {};
let logs = [], tickCount = 0, sessionStart = Date.now(), lastTradeTime = {};
let dailyPnL = 0, dailyStart = state.balance, isHalted = false;

function createFreshState() {
  return { balance: CONFIG.startBalance, positions: [], wins: 0, losses: 0, grossWin: 0, grossLoss: 0, equityCurve: [CONFIG.startBalance], peak: CONFIG.startBalance, streak: 0, totalPips: 0, trades: [] };
}

function loadState() {
  try { const h = location.hash.slice(1); return h ? JSON.parse(atob(h)) : null; } catch { return null; }
}

function saveState() {
  try { history.replaceState(null, '', '#' + btoa(JSON.stringify({ ...state, equityCurve: state.equityCurve.slice(-100) }))); } catch {}
}

function resetBot() {
  state = createFreshState();
  prices = {}; priceHistory = {}; lastPrices = {}; logs = [];
  tickCount = 0; sessionStart = Date.now(); dailyPnL = 0; dailyStart = CONFIG.startBalance; isHalted = false;
  saveState(); log('ðŸ”„ Reset', 'b'); render();
}

// ========== REAL MARKET DATA ==========
async function fetchForexRates() {
  try {
    const res = await fetch('https://api.frankfurter.app/latest?from=USD');
    const data = await res.json();
    rates = { USD: 1, ...data.rates, XAU: 1/2680, XAG: 1/31.5 };
    document.getElementById('apiStatus').textContent = 'API: ECBâœ“';
    document.getElementById('apiStatus').className = 'g';
  } catch {
    rates = { USD: 1, EUR: 0.92, GBP: 0.79, JPY: 156.5, CHF: 0.88, AUD: 1.55, CAD: 1.38, NZD: 1.72, XAU: 1/2680, XAG: 1/31.5 };
    document.getElementById('apiStatus').textContent = 'API: Cache';
    document.getElementById('apiStatus').className = 'y';
  }
}

async function fetchCryptoPrices() {
  try {
    const results = await Promise.all(['BTCUSDT', 'ETHUSDT'].map(s => fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${s}`).then(r => r.json())));
    results.forEach(r => { cryptoPrices[r.symbol.replace('USDT', '')] = parseFloat(r.price); });
  } catch { cryptoPrices = { BTC: 98500, ETH: 3450 }; }
}

// ========== PRICE ENGINE ==========
function calculatePrices() {
  const now = Date.now();
  lastPrices = JSON.parse(JSON.stringify(prices));

  INSTRUMENTS.forEach(inst => {
    if (!priceHistory[inst.sym]) priceHistory[inst.sym] = [];

    let mid;
    if (inst.type === 'crypto') mid = cryptoPrices[inst.base] || (inst.base === 'BTC' ? 98500 : 3450);
    else if (inst.type === 'metal') mid = 1 / (rates[inst.base] || (inst.base === 'XAU' ? 1/2680 : 1/31.5));
    else { mid = (rates[inst.quote] || 1) / (rates[inst.base] || 1); }

    const lastMid = prices[inst.sym]?.mid || mid;
    let volatility;
    if (inst.type === 'crypto') volatility = lastMid * 0.0003;
    else if (inst.type === 'metal') volatility = inst.base === 'XAU' ? 0.8 : 0.02;
    else if (inst.sym.includes('JPY')) volatility = 0.08;
    else volatility = 0.00008;

    const trend = (Math.random() - 0.48) * volatility * 2;
    const meanRev = (mid - lastMid) * 0.015;
    const noise = (Math.random() - 0.5) * volatility * 0.5;
    const momentum = priceHistory[inst.sym].length > 5 ? (priceHistory[inst.sym].slice(-5).reduce((a, b) => a + b, 0) / 5 - lastMid) * 0.01 : 0;
    const newMid = lastMid + trend + meanRev + noise + momentum;

    let spreadValue;
    if (inst.type === 'crypto') spreadValue = newMid * CONFIG.cryptoSpread / 100;
    else if (inst.type === 'metal') spreadValue = CONFIG.metalSpread * inst.pip;
    else spreadValue = CONFIG.forexSpread * inst.pip;

    const bid = newMid - spreadValue / 2, ask = newMid + spreadValue / 2;
    const change = lastPrices[inst.sym] ? (newMid - lastPrices[inst.sym].mid) / inst.pip : 0;

    priceHistory[inst.sym].push(newMid);
    if (priceHistory[inst.sym].length > 100) priceHistory[inst.sym].shift();

    prices[inst.sym] = { bid, ask, mid: newMid, change, pip: inst.pip, type: inst.type, spread: spreadValue / inst.pip, volatility: Math.abs(change), timestamp: now };
  });
  tickCount++;
}

// ========== AI SIGNAL GENERATION ==========
function generateSignal(inst) {
  const p = prices[inst.sym], history = priceHistory[inst.sym] || [], last = lastPrices[inst.sym];
  if (!p || !last || history.length < 20) return { score: 50, confidence: 0, signal: null, strategies: [] };

  let score = 50, confidence = 50;
  const strategies = [];

  // Strategy 1: SMC Order Blocks
  const recentHigh = Math.max(...history.slice(-20)), recentLow = Math.min(...history.slice(-20));
  const range = recentHigh - recentLow, position = (p.mid - recentLow) / range;
  if (position < 0.2) { score += 15; confidence += 10; strategies.push('SMC'); }
  else if (position > 0.8) { score -= 15; confidence += 10; strategies.push('SMC'); }

  // Strategy 2: FVG
  if (history.length >= 3) {
    const [p1, p2, p3] = history.slice(-3), gap = Math.abs(p3 - p1) / inst.pip;
    if (gap > 5) {
      if (p3 > p1 && p.mid < p2) { score += 12; strategies.push('FVG'); }
      else if (p3 < p1 && p.mid > p2) { score -= 12; strategies.push('FVG'); }
      confidence += 8;
    }
  }

  // Strategy 3: Momentum Multi-TF
  const shortMA = history.slice(-5).reduce((a, b) => a + b, 0) / 5;
  const medMA = history.slice(-15).reduce((a, b) => a + b, 0) / Math.min(15, history.length);
  const longMA = history.slice(-30).reduce((a, b) => a + b, 0) / Math.min(30, history.length);
  if (shortMA > medMA && medMA > longMA) { score += 10; confidence += 5; strategies.push('MOMâ†‘'); }
  else if (shortMA < medMA && medMA < longMA) { score -= 10; confidence += 5; strategies.push('MOMâ†“'); }

  // Strategy 4: Bollinger Mean Reversion
  const sma20 = history.slice(-20).reduce((a, b) => a + b, 0) / 20;
  const variance = history.slice(-20).reduce((a, b) => a + Math.pow(b - sma20, 2), 0) / 20;
  const stdDev = Math.sqrt(variance), upperBand = sma20 + stdDev * 2, lowerBand = sma20 - stdDev * 2;
  if (p.mid < lowerBand) { score += 14; confidence += 12; strategies.push('BB'); }
  else if (p.mid > upperBand) { score -= 14; confidence += 12; strategies.push('BB'); }

  // Strategy 5: Breakout
  const avgVolatility = history.slice(-20).reduce((sum, _, i, arr) => i === 0 ? 0 : sum + Math.abs(arr[i] - arr[i-1]), 0) / 19;
  const volRatio = Math.abs(p.change * inst.pip) / (avgVolatility || 1);
  if (volRatio > 2 && Math.abs(p.change) > 2) {
    score += p.change > 0 ? 12 : -12; confidence += 8; strategies.push('BRK');
  }

  // Strategy 6: RSI
  let gains = 0, losses = 0;
  for (let i = 1; i < Math.min(14, history.length); i++) {
    const diff = history[history.length - i] - history[history.length - i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  const rsi = 100 - (100 / (1 + (losses === 0 ? 100 : gains / losses)));
  if (rsi < 25) { score += 10; confidence += 6; strategies.push('RSIâ†‘'); }
  else if (rsi > 75) { score -= 10; confidence += 6; strategies.push('RSIâ†“'); }

  // Strategy 7: Double Bottom/Top
  if (history.length >= 30) {
    const recent = history.slice(-30);
    const localMin1 = Math.min(...recent.slice(0, 10)), localMin2 = Math.min(...recent.slice(20));
    const middle = Math.max(...recent.slice(10, 20));
    if (Math.abs(localMin1 - localMin2) < range * 0.1 && middle > localMin1 * 1.01) { score += 8; confidence += 10; strategies.push('DBL'); }
  }

  // Strategy 8: Correlation
  if (inst.sym === 'EUR/USD' && prices['GBP/USD']) {
    const eurChange = p.change, gbpChange = prices['GBP/USD'].change;
    if ((eurChange > 0 && gbpChange < 0) || (eurChange < 0 && gbpChange > 0)) { score += eurChange > 0 ? 6 : -6; strategies.push('COR'); }
  }

  // Strategy 9: Gold-USD Inverse
  if (inst.sym === 'XAU/USD' && prices['EUR/USD']) {
    const eurChange = prices['EUR/USD'].change;
    if (eurChange > 0.5) score += 8; else if (eurChange < -0.5) score -= 8;
  }

  // Strategy 10: Crypto Momentum
  if (inst.type === 'crypto') {
    if (p.change > 0.3) score += 10; else if (p.change < -0.3) score -= 10;
    confidence += 5; strategies.push('CMOM');
  }

  score = Math.max(0, Math.min(100, Math.round(score)));
  confidence = Math.max(0, Math.min(100, Math.round(confidence)));

  let signal = null;
  if (score >= CONFIG.signalThreshold && confidence >= CONFIG.aiConfidenceMin) signal = 'BUY';
  else if (score <= (100 - CONFIG.signalThreshold) && confidence >= CONFIG.aiConfidenceMin) signal = 'SELL';

  return { score, confidence, signal, strategies };
}

// ========== RISK MANAGEMENT ==========
function calculateKellySize() {
  const total = state.wins + state.losses;
  if (total < 10) return CONFIG.baseRiskPct;
  const winRate = state.wins / total;
  const rr = (state.grossWin / (state.wins || 1)) / (state.grossLoss / (state.losses || 1) || 1);
  const kelly = winRate - ((1 - winRate) / rr);
  return Math.max(CONFIG.baseRiskPct * 0.5, Math.min(CONFIG.baseRiskPct * 2, Math.max(0.1, Math.min(2, kelly * CONFIG.kellyFraction))));
}

function checkRiskLimits() {
  const equity = calculateEquity();
  const drawdown = ((state.peak - equity) / state.peak) * 100;
  const dailyLossPct = ((dailyStart - state.balance) / dailyStart) * 100;
  const riskEl = document.getElementById('riskLevel');

  if (drawdown >= CONFIG.maxDrawdownPct || dailyLossPct >= CONFIG.dailyLossLimitPct) {
    isHalted = true; riskEl.textContent = 'HALT'; riskEl.className = 'r';
    log('ðŸš¨ HALTED', 'r'); return false;
  } else if (drawdown > 5 || dailyLossPct > 3) {
    riskEl.textContent = 'HIGH'; riskEl.className = 'y';
  } else { riskEl.textContent = 'LOW'; riskEl.className = 'g'; }
  return true;
}

function getCorrelationGroup(sym) {
  if (sym.includes('USD')) return 'USD';
  if (sym.includes('EUR')) return 'EUR';
  if (sym.includes('GBP')) return 'GBP';
  if (sym.includes('JPY')) return 'JPY';
  if (sym.includes('AUD') || sym.includes('NZD')) return 'COMM';
  if (sym.includes('BTC') || sym.includes('ETH')) return 'CRYPTO';
  if (sym.includes('XAU') || sym.includes('XAG')) return 'METAL';
  return 'OTHER';
}

function canOpenPosition(sym) {
  if (isHalted || state.positions.length >= CONFIG.maxPositions) return false;
  if (state.positions.find(p => p.sym === sym)) return false;
  const group = getCorrelationGroup(sym);
  if (state.positions.filter(p => getCorrelationGroup(p.sym) === group).length >= CONFIG.maxCorrelatedPos) return false;
  if (lastTradeTime[sym] && Date.now() - lastTradeTime[sym] < CONFIG.cooldownMs) return false;
  return true;
}

// ========== TRADING ENGINE ==========
function executeTrades() {
  if (!checkRiskLimits()) return;
  INSTRUMENTS.forEach(inst => {
    const p = prices[inst.sym]; if (!p) return;
    const { signal, confidence, strategies } = generateSignal(inst);
    if (signal && canOpenPosition(inst.sym)) openPosition(inst, signal, confidence, strategies);
  });
  manageOpenPositions();
}

function openPosition(inst, direction, confidence, strategies) {
  const p = prices[inst.sym], kellySize = calculateKellySize();
  const riskAmount = state.balance * (kellySize / 100), slPips = CONFIG.baseSlPips;
  let pipValue = inst.type === 'crypto' ? 0.01 : inst.type === 'metal' ? (inst.base === 'XAU' ? 0.1 : 0.5) : 0.0001;
  const lot = Math.max(CONFIG.minLot, Math.min(CONFIG.maxLot, riskAmount / (slPips * pipValue * 1000)));
  const isBuy = direction === 'BUY', entry = isBuy ? p.ask : p.bid;
  const tpDist = CONFIG.baseTpPips * inst.pip, slDist = CONFIG.baseSlPips * inst.pip;

  state.positions.push({
    sym: inst.sym, type: direction, entry, lot,
    tp: isBuy ? entry + tpDist : entry - tpDist,
    sl: isBuy ? entry - slDist : entry + slDist,
    originalSl: isBuy ? entry - slDist : entry + slDist,
    trail: null, breakEven: false, pip: inst.pip,
    pipValue: lot * 1000 * pipValue, confidence, strategies, openTime: Date.now()
  });
  lastTradeTime[inst.sym] = Date.now();
  log(`${direction} ${inst.sym} @${formatPrice(inst.sym, entry)} [${strategies.join('+')}]`, isBuy ? 'g' : 'r');
  saveState();
}

function manageOpenPositions() {
  const toClose = [];
  state.positions.forEach((pos, idx) => {
    const p = prices[pos.sym]; if (!p) return;
    const isBuy = pos.type === 'BUY', current = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (current - pos.entry) / pos.pip : (pos.entry - current) / pos.pip;

    // Break Even
    if (!pos.breakEven && pips >= CONFIG.breakEvenPips) {
      pos.sl = isBuy ? pos.entry + (pos.pip * 0.5) : pos.entry - (pos.pip * 0.5);
      pos.breakEven = true; log(`BE ${pos.sym}`, 'y');
    }

    // Trailing Stop
    if (pips >= CONFIG.trailActivatePips) {
      const newTrail = isBuy ? current - (CONFIG.trailDistancePips * pos.pip) : current + (CONFIG.trailDistancePips * pos.pip);
      if (!pos.trail || (isBuy && newTrail > pos.trail) || (!isBuy && newTrail < pos.trail)) { pos.trail = newTrail; pos.sl = newTrail; }
    }

    // Exit Conditions
    let exitReason = null;
    if (isBuy) {
      if (current >= pos.tp) exitReason = 'TP';
      else if (current <= pos.sl) exitReason = pos.trail ? 'TRAIL' : (pos.breakEven ? 'BE' : 'SL');
    } else {
      if (current <= pos.tp) exitReason = 'TP';
      else if (current >= pos.sl) exitReason = pos.trail ? 'TRAIL' : (pos.breakEven ? 'BE' : 'SL');
    }

    if (exitReason) {
      const pnl = pips * pos.pipValue;
      state.balance += pnl; dailyPnL += pnl; state.totalPips += pips;
      if (pnl > 0) { state.wins++; state.grossWin += pnl; state.streak = state.streak > 0 ? state.streak + 1 : 1; }
      else { state.losses++; state.grossLoss += Math.abs(pnl); state.streak = state.streak < 0 ? state.streak - 1 : -1; }
      if (state.balance > state.peak) state.peak = state.balance;
      log(`${exitReason} ${pos.sym} ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}`, pnl >= 0 ? 'g' : 'r');
      toClose.push(idx);
    }
  });
  if (toClose.length) { state.positions = state.positions.filter((_, i) => !toClose.includes(i)); saveState(); }
}

function calculateEquity() {
  let unrealized = 0;
  state.positions.forEach(pos => {
    const p = prices[pos.sym]; if (!p) return;
    const isBuy = pos.type === 'BUY', current = isBuy ? p.bid : p.ask;
    unrealized += (isBuy ? (current - pos.entry) / pos.pip : (pos.entry - current) / pos.pip) * pos.pipValue;
  });
  return state.balance + unrealized;
}

// ========== HELPERS ==========
function log(msg, cls = '') { logs.unshift({ msg, cls, time: Date.now() }); if (logs.length > 50) logs.pop(); }
function formatPrice(sym, price) {
  if (sym.includes('JPY')) return price.toFixed(3);
  if (sym.includes('XAU')) return price.toFixed(2);
  if (sym.includes('XAG')) return price.toFixed(4);
  if (sym.includes('BTC') || sym.includes('ETH')) return price.toFixed(2);
  return price.toFixed(5);
}

// ========== RENDER ==========
function render() {
  const equity = calculateEquity(), pnl = equity - CONFIG.startBalance;
  const total = state.wins + state.losses, winRate = total > 0 ? (state.wins / total * 100) : 0;
  const pf = state.grossLoss > 0 ? (state.grossWin / state.grossLoss) : 0;
  const dd = state.peak > 0 ? ((state.peak - equity) / state.peak * 100) : 0;
  const sharpe = total > 5 ? ((pnl / CONFIG.startBalance * 100) / (dd || 1) * 0.5).toFixed(2) : '0.00';

  document.getElementById('equity').textContent = '$' + equity.toFixed(2);
  document.getElementById('equity').className = 'big ' + (pnl >= 0 ? 'g' : 'r');
  document.getElementById('pnl').textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
  document.getElementById('pnl').className = pnl >= 0 ? 'g' : 'r';
  document.getElementById('trades').textContent = total;
  document.getElementById('winrate').textContent = winRate.toFixed(0) + '%';
  document.getElementById('pf').textContent = pf.toFixed(2);
  document.getElementById('openPos').textContent = state.positions.length + '/' + CONFIG.maxPositions;
  document.getElementById('streak').textContent = (state.streak > 0 ? '+' : '') + state.streak;
  document.getElementById('streak').className = state.streak > 0 ? 'g' : state.streak < 0 ? 'r' : '';
  document.getElementById('peak').textContent = '$' + state.peak.toFixed(2);
  document.getElementById('dd').textContent = dd.toFixed(1) + '%';
  document.getElementById('sharpe').textContent = sharpe;
  document.getElementById('kellySize').textContent = calculateKellySize().toFixed(1) + '%';
  document.getElementById('tickCount').textContent = tickCount;
  document.getElementById('marketTime').textContent = new Date().toLocaleTimeString();
  document.getElementById('latency').textContent = CONFIG.tickInterval + 'ms';

  // Status
  const statusEl = document.getElementById('status');
  statusEl.textContent = isHalted ? 'HALT' : 'LIVE';
  statusEl.className = isHalted ? 'r' : 'g';

  // Risk bars
  const dailyUsedPct = Math.abs((dailyStart - state.balance) / dailyStart * 100);
  document.getElementById('dailyBar').style.width = Math.min(100, dailyUsedPct / CONFIG.dailyLossLimitPct * 100) + '%';
  document.getElementById('dailyUsed').textContent = dailyUsedPct.toFixed(1) + '%';
  document.getElementById('ddBar').style.width = Math.min(100, dd / CONFIG.maxDrawdownPct * 100) + '%';
  document.getElementById('ddUsed').textContent = dd.toFixed(1) + '%';
  const expPct = (state.positions.length / CONFIG.maxPositions) * 100;
  document.getElementById('expBar').style.width = expPct + '%';
  document.getElementById('exposure').textContent = expPct.toFixed(0) + '%';

  // Market table
  let tableHtml = '';
  INSTRUMENTS.forEach(inst => {
    const p = prices[inst.sym]; if (!p) return;
    const sig = generateSignal(inst);
    const pos = state.positions.find(po => po.sym === inst.sym);
    let posPnl = 0;
    if (pos) {
      const isBuy = pos.type === 'BUY', current = isBuy ? p.bid : p.ask;
      posPnl = (isBuy ? (current - pos.entry) / pos.pip : (pos.entry - current) / pos.pip) * pos.pipValue;
    }
    tableHtml += `<tr>
      <td><b>${inst.sym}</b></td>
      <td>${formatPrice(inst.sym, p.bid)}</td>
      <td>${formatPrice(inst.sym, p.ask)}</td>
      <td class="${p.change >= 0 ? 'g' : 'r'}">${p.change >= 0 ? '+' : ''}${p.change.toFixed(1)}</td>
      <td class="m">${(p.volatility * 10).toFixed(1)}</td>
      <td>${sig.score}</td>
      <td class="${sig.signal === 'BUY' ? 'g' : sig.signal === 'SELL' ? 'r' : 'm'}"><b>${sig.signal || '--'}</b></td>
      <td class="${posPnl >= 0 ? 'g' : 'r'}">${pos ? '$' + posPnl.toFixed(2) : '--'}</td>
    </tr>`;
  });
  document.getElementById('marketTable').innerHTML = tableHtml;

  // Positions
  const posEl = document.getElementById('positions');
  if (state.positions.length === 0) posEl.innerHTML = '<span class="m">Scanning...</span>';
  else posEl.innerHTML = state.positions.map(pos => {
    const p = prices[pos.sym], isBuy = pos.type === 'BUY', current = isBuy ? p.bid : p.ask;
    const pips = isBuy ? (current - pos.entry) / pos.pip : (pos.entry - current) / pos.pip;
    const pnl = pips * pos.pipValue;
    return `<div class="pos${isBuy ? '' : ' sell'}"><b>${pos.sym}</b> ${pos.lot}L | <span class="${pnl >= 0 ? 'g' : 'r'}">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}</span> <span class="m">(${pips.toFixed(1)}p)</span></div>`;
  }).join('');

  // Log
  document.getElementById('tradeLog').innerHTML = logs.map(l => `<div class="log"><span class="m">[${new Date(l.time).toLocaleTimeString([], {hour12:false})}]</span> <span class="${l.cls}">${l.msg}</span></div>`).join('');

  // Equity chart
  const chartEl = document.getElementById('equityChart');
  const maxVal = Math.max(...state.equityCurve, state.peak), minVal = Math.min(...state.equityCurve, CONFIG.startBalance);
  const range = maxVal - minVal || 1;
  chartEl.innerHTML = state.equityCurve.slice(-50).map(val => `<div style="height:${Math.max(5, ((val - minVal) / range * 100))}%"></div>`).join('');
  document.getElementById('chartPeak').textContent = 'Peak: $' + state.peak.toFixed(2);
}

// ========== MAIN LOOP ==========
async function loop() {
  if (tickCount % 100 === 0) { await fetchForexRates(); await fetchCryptoPrices(); }
  calculatePrices();
  executeTrades();
  if (tickCount % 5 === 0) {
    state.equityCurve.push(calculateEquity());
    if (state.equityCurve.length > 200) state.equityCurve.shift();
    render();
  }
  setTimeout(loop, CONFIG.tickInterval);
}

// Boot
fetchForexRates().then(() => { fetchCryptoPrices().then(() => { log('ðŸš€ Engine Online', 'g'); loop(); }); });
</script>
</body>
</html>






